
# java 虚拟机结构 

## 数据类型
java虚拟机可以操作的数据类型可分为原始类型(primitive type)和引用类型(reference type)。与之对应，存在原始值和引用值两种类型数值。

### 原始类型和值 
java虚拟机所支持的原始数据类型包括 数值类型(numeric type)、boolean类型和returnAddress类型。

数值类型又分为整数类型和浮点类型。

整数类型
- byte 8位有符号二进制补码整数 [-127, 128]
- short 16位有符号二进制补码整数  [-32768, 32767]
- int 32位有符号二进制补码整数 [-2147483648, 2147483647]
- long 64位有符号二进制补码整数 [-9223372036854775808, 9223372036854775807]
- char 值为16位无符号整数表示的，指向基本多文种平面(Basic Multilingual Plane BMP)的Unicode码点，以UTF-16编码。 [0. 65535]

浮点数
- float 值为单精度浮点数集合中的元素，或者单精度扩展指数集合中的元素。
- double 值为双精度浮点数集合中的元素，或者双精度扩展指数集合中的元素。

与 IEEE 754 标准定义的32位单精度和64位双精度格式的取值和操作相同。    
格式 S|阶码|尾数    
float 阶码长度8 尾数长度23 值 = (-1)^S * (1 + 0.尾数) * 2^(阶 - 127)    
float 扩展指数 阶码>=11 尾数23    
double 阶码长度11 尾数长度52 值 = (-1)^S * (1 + 0.尾数) * 2^(阶 - 1023)    
double 扩展指数 阶码>=15 尾数23    
扩展指数集合有比相应标准浮点数集合更大的指数取值范围，但不会有更高的精度    

特殊的数值: 正数0 负数0 正无穷大 负无穷大 NaN    
除Nan外，浮点数集合中的所有元素都有有序的。 负无穷 < 负数 < 负数0 < 正数0 < 正数 < 正无穷    
只要操作数是NaN，那么对它进行的所有数值比较和等值比较都会返回 false;有且只有NaN与自身比较 不等值时返回 false，其它情况下返回 true。

boolean类型    
虚拟机中用int数据类型来代替boolean。用 byte数组代替 boolean数组。

### 引用类型和值
虚拟机中有三种引用类型: 类类型、数组类型和接口类型。
这些引用类型的值分别指向动态创建的类实例、数组实例和实现了某个接口的类实例或数组实例。

## 运行时数据区
虚拟机定义了若干种程序 运行期间会使用到的数据区。
其中有一些会随着虚拟机启动而创建，随着虚拟机退出而销毁。
另外一些则是与线程一一对应的，这些数据区随着线程的开始的结束而创建和销毁。

### pc寄存器
每条线程都有自己的pc寄存器。在任意时刻，一条线程只会执行一个方法的代码，这个正在被执行的方法称为该线程的当前方法。
如果当前方法不是native，那么pc寄存器就保存着虚拟机正在执行的字节码指令的地址。
如果当前方法是native,那么pc寄存器的值j undefined。

### Java虚拟机栈 Stack
每条线程都有自己的私有的 Java虚拟机栈(Java Virtual Machine stack)，这个栈与线程同时创建，用于存储栈帧。与传统语言中的栈非常类似。
Java虚拟机栈可以实现成固定大小，也可以根据计算动态扩展和收缩。    
Java虚拟机栈可能发生如下异常
- StackOverflowError 如果线程请求分配的栈容量超过了虚拟机允许的最大容量，将抛出
- OutOfMemoryError 如果虚拟机栈可以动态扩展，并且尝试扩展的时候无法申请到足够的内存或者创建新的线程时没有足够的内存去创建对应的虚拟机栈时，会抛出

### Java堆 Heap
堆是可供各线程共享的运行时内存区域，也是供所有类实例和数组对象分配内存的区域。    
堆在虚拟机启动时被创建，它存储着被自动内存管理系统(automatic storage management system)，也就是垃圾收集器(garbage collector)所管理的对象。
Java堆的容量可以是固定的，也可以随着程序执行的需求动态扩展，并在不需要的时候自动收缩。Java堆所使用的内存不需要保证是连续的。    
Java堆可能发生以下异常
- OutOfMemoryError 实际所需的堆超过了自动内存管理系统能提供的最大容量，将抛出

### 方法区
方法区是可供各个线程共享的运行时内存区域。方法区与传统语言中的编译代码存储区或操作系统进程的正文段的作用非常类型，它存储了每个类的结构信息。
例如，运行时常量池、字段和方法数据、构造函数和普通方法的字节码内容，还包括一些在类、实例、接口初始化时用到的特殊方法。    
方法区可能发生如下异常
- OutOfMemoryError 方法区的内存空间不能满足内存分配请求

### 运行时常量池
运行时常量池是class文件中每个类或接口的常量池表的运行时表示形式，它包括若干种不同的常量，从编译期可知的数值字面量到必须运行期解析后才能获得的方法或字段引用。
运行时常量池类似于传统语言中的符号表，不过它存储数据的范围比通常意义上的符号表要更广泛。    
每个运行时常量池都在Java虚拟机的方法区中分配，在类加载类和接口到虚拟机后，就创建对应的运行时常量池。    
在创建类和接口的运行常量池时，可能发生如下异常
- OutOfMemoryError 当创建类或接口时，如果构造运行时常量所需要的内存空间超过方法区所能提供的最大值，将抛出。

### 本地方法栈
Java虚拟机实现可能 会使用到传统的栈(通常称为C stack)来支持native方法的执行，这个栈就是本地方法栈。    
本地方法栈可能发生如下异常
- StackOverflowError 如果线程请求分配的栈容量超过了虚拟机允许的最大容量，将抛出
- OutOfMemoryError 如果虚拟机栈可以动态扩展，并且尝试扩展的时候无法申请到足够的内存或者创建新的线程时没有足够的内存去创建对应的虚拟机栈时，会抛出

## 栈帧
栈帧是用来存储数据和部分过程结果的数据结构，同时也用来处理动态链接、方法返回和异常分派。
栈帧随着方法的调用而创建，随着方法的结束而销毁--无论方法是正常结束还是异常完成。栈帧的存储空间由创建它的线程分配在Java虚拟机栈中。
每个栈帧都有自己的本地变量表、操作数表和指向当前方法所属的类的运行时常量池的引用。    
本地变量表的操作数栈的容量在编译期间确定，并通过相关方法code属性保存及提供给栈帧使用。    
在某条线程执行过程中的某个时间点上，只有目前正在执行的方法的栈帧是活动的，这个栈帧称为 当前栈帧，这个栈帧对应的方法称为 当前方法，定义这个方法的类称为 当前类。
对局部变量表和操作数栈的各种操作，通常都指的是对当前栈帧的局部变量表和操作数表所进行的操作。

### 局部变量表
每个栈帧内部都包含一组称为局部变量表的变量列表。栈帧中局部变量表的长度由编译期间决定，并且存储在类或接口的二进制表示中，即通过方法的code属性保存及提供给栈帧使用。    

一个局部变量可以保存一个类型为 boolean\byte\char\short\int\float\reference\returnAddress的数据，
两个局部变量可以保存一个类型为 long\doubler的数据。

局部变量使用索引来进行定位访问。long\double类型的数据占用两个连续的局部变量，采用两个局部变量中较小的索引值来定位。

Java虚拟机使用局部变量表来完成方法调用时的参数传递。当调用方法时，它的参数会依次传递到局部变量表中从0开始的连续的位置上。
当调用实例方法时，第0个局部变量一定是用来存储实例方法所在对象的引用(即 this 关键字)。后续的其它参数将会传递到局部变量表中从1开始的连续位置上。

### 操作数栈
每个栈帧内部都包含一个称为操作数栈的 FIFO栈。栈帧中操作数栈的最大深度由编译期间决定，并且通过方法的code属性保存及提供给栈帧使用。
栈帧创建时，操作数栈是空的。
Java虚拟机提供一些字节码指令来从局部变量表或对象实例的字段中复制常量或变量值到操作数栈中，
也提供了一些指令用于从操作数栈取走数据、操作数据以及把操作结果重新入栈。在调用方法时，操作数栈也用来准备调用方法的参数以及接收方法返回结果。

### 动态链接
每个栈内部都包含一个指向当前方法所在类型的运行时常量池的引用，以便对当前方法的代码实现动态链接。
在class文件中，一个方法若要调用其他方法，或者访问成员变量，则需要通过符号引用来表示，
动态链接的作用就是将这些符号引用所表示的方法转换为对实际方法的直接引用。

### 方法调用正常完成
方法正常完成时，很可能返回一个值给调用它的方法。方法正常完成发生在一个方法执行过程中遇到了方法返回的字节码指令时。
使用哪种指令取决于方法返回值的数据类型。
在这种情况下，当前栈帧承担着恢复调用者状态的责任，包含恢复调用者的局部变量表和操作数表，以及正确递增pc寄存器，以跳过刚才执行的方法调用指令。
调用者的代码在被调用方法的返回值压入调用者栈帧的操作数栈后，会继续执行。

### 方法调用异常完成
方法执行过程中，某些指令导致了Java虚拟机抛出异常，并且虚拟机抛出的异常在该方法中没有办法处理，
或者执行过程中遇到athrow字节码指令并显式抛出异常，同时该方法内部没有捕获异常。
如果方法异常调用完成，不会有返回值返回给调用者。

## 浮点算法
Java虚拟机和IEEE 754中的浮点算法主要差别
- Java虚拟机浮点操作在遇到非法操作时不会抛出异常
- Java虚拟机不支持IEEE 754中的信号浮点数比较
- Java虚拟机中舍入永远使用向最接近数舍入模式。将浮点数转化为整数值使用向零舍入。
- Java虚拟机扩展只扩展了指数的范围。IEEE 754中的扩展格式不仅扩展了指数的范围，而且扩展了精度。

### 浮点数模式
每个方法都有一项属性称为浮点数模式，取值有两种 FP-strict模式和 非FP-strict模式

说一个操作数栈具有某种给定浮点模式，所指的就是包含操作数栈的栈帧所对应的方法具备的浮点模式，
类似的，我们说一条Java虚拟机字节码指令具备某种浮点模式，所指的也是包含这条指令的方法具备的浮点模式。

类和实例的字段、数组元素、本地变量和方法参数的取值范围都限于标准的数值集合中。

### 数值集合的转换
标准浮点数集合与扩展指数集合之间的映射操作称为 数据集合的转换。是同一种数值类型的不同数值集合间进行映射。

数据集合转换发生的位置，虚拟机实现允许对数值执行下面操作之一
- 如果一个数值是float类型，并且不是单精度浮点数集合中的元素，允许将其映射到单精度浮点数集合中数值最接近的元素
- 如果一个数值是double类型，并且不是双精度浮点数集合中的元素，允许将其映射到双精度浮点数集合中数值最接近的元素

此外，在数值集合转换发生的位置，下面的操作是必需的。
- 假设正在执行的Java虚拟机字节码指令是非FP-strict模式的，但这个指令导致一个float类型的值压入一个FP-strict模式的操作数栈中，或作为参数进行传递，
或存储进局部变量字段或数组元素中。如果这个数值不是单精度浮点数集合中的元素，则必须将其映射到单精度浮点数集合中数值最接近的元素。
- double 类似

在方法调用中传递参数，在非FP-strict模式的方法返回浮点类型的结果到FP-strict模式的方法，或者在非FP-strict模式的方法中存储浮点数值到局部变量、字段或数组中时，都必须执行上述数值集合转换。

## 特殊方法
在虚拟机中，构造器是以一个名为 <init> 的特殊实例初始化方法的形式出现的。
实例初始化方法只能在实例初始化期间，通过Java虚拟机的 invoke special 指令调用，而且只能在尚未鹤立鸡群 化的实例上调用该指令。

一个类或接口最多可以包含不超过一个类或接口的初始化方法，类或接口通过这个方法完成初始化。这个方法是一个不包含参数的，返回值为void的方法，
名为 <clinit>。当class版本号不小于51.00时，必须设置 ACC_STATIC 标志。初始化方法由虚拟机隐式调用，没有任何指令可以调用这个方法。

当一个方法具有 签名多态性， 则意味着这个方法满足以下全部条件
- 通过 java.lang.invoke.MethodHandle 类进行申明 
- 只有一个类型为Object[] 的形参
- 返回值为Object
- ACC_VARARGS 和 ACC_NATIVE 标志被设置
在java se 8 中，只有 java.lang.invoke.MethodHandle 的 invoke 和 invokeExact 是签名多态性方法。
在Java se 8 中， invoke virtual 指令将对具有签名多态性的方法进行特殊处理，以保证方法句柄能够正常调用。
方法句柄是一种可以直接进行的强类型引用，它可以指向相关的方法、构造器、字段或其他低级操作，并具有参数和返回值转换能力。
即对原方法执行转化、插入、删除及替换等模式的变换

## 异常
抛异常实际上是程序控制权的一种即时的，非局部的转换--从抛出的地方转换至处理的地方。
由于当前线程的某个操作导致的异常 称为同步异常。与之相反，异步异常可以在程序执行过程中随时发生。
java虚拟机中的异常出现总是由下面三种原因之一导致的
- athrow 指令
- 虚拟机同步检测到程序发生了非正常的执行情况，这时异常必将紧接着在发生非正常执行情况的字节码指令之后抛出
如程
    - 序执行的操作引发异常(访问数组越界， 程序在加载连接时出现错误)
    - 使用某些资源时产生资源限制，例如使用太多的内存
- 由于以下原因导致异步异常的出现
    - 调用 Thread或ThreadGroup的stop方法
    - Java虚拟机实现发生了内部错误

## 字节码指令集简介
java虚拟机指令由一个字节长度的、代表某种特定操作含义的操作码以及跟随其后的零至多个代表些操作所需参数的操作数所构成。
操作数的数量以及长度取决于操作码，如果一个操作数长度超过一个字节，那么它将会以big-endian顺序存储。
字节码指令流通常都是单字节对齐的。只有table switch 和 lookup switch 例外，它们是4字节对齐。

### 数据类型与Java虚拟机
i ing; l long; s short; c char; f float; d double; a reference;
在编译或运行期间，将byte short数据带符号扩展为相应的int，boolean char数据零位扩展为int。
与之类似，在处理数组时，也会转换为相应的int数组指令来处理。

### 加载和存储指令
用于将数据从栈帧的本地变量表和操作数栈之间来回传递。
- 将本地变量加载到操作数栈 iload iload_<n> lload lload_<n> fload fload_<n> dload dload_<n> aload aload_<n>
- 将操作数栈存储到局部变量表 istore istore_<n> lstore lstore_<n> fstore fstore_<n> dstore sdtore_<n> astore astore_<n>
- 将一个常量加载到操作数栈 pipush sipush ldc ldc_w ldc2_w aconst_null iconst_ml iconst_<i> lconst_<l> fconst_<f> dconst_<d>
- 扩充局部变量表的访问索引或立即数 wide
有一部分以<>结尾的指令代表一组指令 iload_<n> iload_0 iload_1 iload_2 iload_3

### 算术指令
- 加 iadd ladd fadd dadd
- 减 isub lsub fsub dsub
- 乘 imul lmul fmul dmul
- 除 idiv ldiv fdiv ddiv 
- 求余 irem lrem frem drem 
- 求负 ineg lneg fneg dneg
- 移位 ishl ishr iushr lshl lshr lushr
- 按位或 ior lor
- 按位与 iand land
- 按位异或 ixor lxor
- 局部变量自增 iinc 
- 比较 dcmpg dcmpl fcmpg fcmpl lcmp
只有整数除 idiv ldiv 和整数求余 irem lrem 在除数为 0 时会招聘 ArithmeticException异常

### 类型转换指令
java虚拟机直接支持以下数值宽化类型转换 
- 从 int 到 long float double    i2l i2f i2d
- 从 long 到 float double    l2f l2d
- 从 float 到 double    f2d
从int long 转换成 float double 时将可能发生精度丢失。
从 byte char short 到 int 类型的宽化类型转换实际上是不存在的。
Java虚拟机支持以下数值窄化类型转换
- 从 int 到 byte short char    i2b i2s i2c
- 从 long 到 int    l2i
- 从 float 到 int long    f2i f2l
- 从 double 到 int long float    d2i d2l d2f
窄化类型转换可能导致结果具备不同的正负号，不同的数量级。将int long窄化时，转换过程只是简单的丢弃除最低N个二进制位以外的内容。
将浮点数值窄化为整数时，遵循以下规则
- 如果数值是NaN，那结果就是0
- 如果浮点值不是无穷，那么依照向零舍入模式取整
- 如果转换结果太小或太大，则用int long所能表示的最小最大数值

### 对象的创建与操作
- 创建类实例对象 new 
- 创建数组 newarray anewarray multianewarray
- 访问类字段 getfield putfield getstatic putstatic
- 把一个数组元素加载到操作数栈 baload caload saload iaload laload faload daload aaload
- 将操作数栈存储到数组元素中 bastore castore sastore iastore lastore dastore aastore
- 取数组长度 arraylength
- 检查实例或数组类型 instanceof chechcast

### 操作数栈管理
pop pop2 dup dup2 dup_x1 dup_x2 dup_x2 swap

### 控制转移
- 条件分支 ifeq ifne ielt ifle ifgt ifge ifnull ifnonull if_icmpeq if_icmpne if_icmplt if_icmpgt if_icmpge if_icmpeq if_icmpne
- 复合条件分支 tableswitch lookupswitch
- 无条分支 goto goto_w jsr jsr_w ret
控制转移都使用int类型的比较 对于long float double类型，则先执行算术指令中的比较运算指令，算术运算指令返回一个整数值到操作数栈中，随便再执行int类型的条件分支。

### 方法调用和返回
- invokevirtual 调用对象的实例方法，根据对象的实际类型进行分派
- invokeinterface 调用接口方法，它会在运行时搜索由特定对象所实现的这个接口方法
- invokespecial 调用特殊方法，包括 实例初始化方法、私有方法和父类方法
- invokestatic 调用static方法
- invokedynamic 调用绑定了invokedynamic指令的调用点对象作为目标方法。
- 方法返回指令根据返回值类型进行分类 ireturn lreturn freturn dreturn areturn return(用于声明为void的方法 实例初始化方法 类和接口的类初始化方法)

### 抛出异常
athrow

### 同步
- 方法级同步
方法级同步是隐式的，即无需通过字节码指令来控制，实现在方法调用和返回操作之中。从方法常量池中的方法表结构中的ACC_SYNCHRONIZED访问标志区分一个方法是否是同步方法。
当调用方法，如果设置了该访问标志，执行线程将先持有同步锁，然后执行方法，在方法完成时释放同步锁。
- 指令序列的同步
指令序列同步通常用来表示java语言中的synchronised块， 虚拟机的指令集中有monitorenter和minitoreexit两个指令来支持。 
